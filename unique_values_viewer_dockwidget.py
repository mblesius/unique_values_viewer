# -*- coding: utf-8 -*-
"""
/***************************************************************************
 UniqueValuesViewer
                                 A QGIS plugin
 A simple plugin that allows you to display the unique values for a field of
 a vector layer in a widget. Values can be copied and corresponding features be
 selected through the widget.

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-09-18
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Malik Blesius
        email                : malik.blesius@foea.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import Qt, QEvent, pyqtSignal
from qgis.PyQt.QtWidgets import (QAbstractItemView,
                                 QApplication,
                                 QAction,
                                 QListWidgetItem,
                                 QMenu)

from qgis.gui import QgsFilterLineEdit, QgsDockWidget
from qgis.core import Qgis, QgsVectorLayer

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'unique_values_viewer_dockwidget_base.ui'))

# Commented providers are included in the combobox
# TODO: Make plugin able to work with classified rasters and other data providers
EXCLUDE_PROVIDERS = [
    'arcgisfeatureserver',
    'arcgismapserver',
    'DB2',
    'delimitedtext',
    'gdal',
    'geonode',
    'mdal',
    'mesh_memory',
    'mssql',
    'ows',
    'postgres',
    'spatialite',
    'virtual',
    'wcs',
    'WFS',
    'wms'
]


class UniqueValuesViewerDockWidget(QgsDockWidget, FORM_CLASS):
    """ Widget for the plugin. """

    closingPlugin = pyqtSignal()

    @property
    def field(self):
        return self._field

    @field.setter
    def field(self, field):
        self._field = field

    @property
    def fieldType(self):
        return self._fieldType

    @fieldType.setter
    def fieldType(self, fieldType):
        self._fieldType = fieldType

    @property
    def mapLayer(self):
        """ Getter method for the current map layer of the combo box """
        return self._mapLayer

    @mapLayer.setter
    def mapLayer(self, lyr):
        """ Setter method for the current map layer of the combo box """
        self._mapLayer = lyr

    def __init__(self, iface, plugin_dir, parent=None):
        """Constructor."""
        super(UniqueValuesViewerDockWidget, self).__init__(parent)
        # TODO: Maybe improve UI by replacing QListWidget with QgsListWidget
        self.setupUi(self)
        self.iface = iface

        self.mMapLayerComboBox.setExcludedProviders(EXCLUDE_PROVIDERS)

        # init properties
        self._mapLayer = self.mMapLayerComboBox.currentLayer()
        self._field = None
        self._fieldType = None

        # TODO: convert to property?
        self.unique_values = []

        self.null_item = QListWidgetItem("NULL")
        self.contains_null = None
        self.sorting_enabled = True
        self.search_results = set()

        self.plugin_dir = plugin_dir

        # install event filter for context menu
        self.listWidget.installEventFilter(self)

        # connect widgets to slots
        self.mMapLayerComboBox.layerChanged.connect(self.change_layer)
        self.mFieldComboBox.fieldChanged.connect(self.change_field)
        self.getValuesBtn.clicked.connect(self.update_values)
        self.clearBtn.clicked.connect(self.clear_listWidget)
        self.iface.currentLayerChanged.connect(self.sync_iface_layer_changed)

        self.valueSearch.textChanged.connect(self.search_value)
        self.valueSearch.cleared.connect(self.show_values)

        self.sortValuesBtn.toggled.connect(self.change_sorting)
        self.liveUpdateBtn.toggled.connect(self.change_update_on_selection)
        self.selectedOnlyBtn.toggled.connect(self.enable_only_selected_features)

        # Clear selection of ListWidget Items when search bar is cleared
        self.valueSearch.cleared.connect(self.listWidget.clearSelection)

        # set initial field
        if self._mapLayer:
            self.change_layer()

    def add_to_selection(self):
        """ """
        expr = self.build_expression()
        self.mapLayer.selectByExpression(expr, behavior=QgsVectorLayer.AddToSelection)

    def build_expression(self):
        """ Build a selection expression based on the selected unique values
        of the current attribute field

        :returns: The expression to use in the expression builder for selection
        :rtype: str
        """

        null_item_was_selected = False

        # check if field contains NULL-Values through null_item of list widget
        if self.null_item.isSelected():
            self.null_item.setSelected(False)
            null_item_was_selected = True

        # List of items will be empty if only the null item was selected
        items = self.listWidget.selectedItems()

        # build expression in case only NULL-Values should be selected
        if not items:
            expr = f"\"{self.field}\" is Null"
        # build expression in case all but the NULL-Value are selected
        elif ((self.contains_null and not null_item_was_selected)
              and (len(items) == self.listWidget.count() - 1)):
            expr = f"\"{self.field}\" is not Null"
        # build expressions for any other case
        else:
            # TODO: Improve for different field types,
            #       make the search bar work in reasonable manner according to field type

            # build expression based on field type
            expr = f"\"{self.field}\" in ("
            if self.fieldType.lower() == "string":
                for item in items:
                    if "'" in item.text():
                        text = item.text().replace("'", "''")
                        expr += f"'{text}',"
                    else:
                        expr += f"'{item.text()}',"

            elif self.fieldType.lower() in {'time',
                                            'datetime',
                                            'date'}:
                for item in items:
                    expr += f"'{item.text()}',"

            elif self.fieldType.lower() in {"double",
                                            "real",
                                            "integer",
                                            "integer64"}:
                for item in items:
                    expr += f"{item.text()},"

            elif self.fieldType.lower() == 'boolean':
                # Boolean field can only hold true, false or None/NULL
                if len(items) == 1:
                    expr = f"(\"{self.field}\" is {items[0].text()} "
                elif len(items) == 2:
                    expr = f"(\"{self.field}\" is {items[0].text()}" \
                           f" or \"{self.field}\" is {items[1].text()} "
                else:
                    return None
            else:
                return None

            # Close expression for scheme "value in (...)"
            expr = expr[:-1] + ")"

            # Add expression part if NULL values should be selected
            if null_item_was_selected:
                expr += f" or \"{self.field}\" is Null"

        if null_item_was_selected:
            self.null_item.setSelected(True)
        return expr

    def change_field(self):
        """ Changes the field property of the DockWidget Plugin Class """
        self.contains_null = None
        self.field = self.mFieldComboBox.currentField()

        # get the typeName by fieldNameIndex, because currentField returns str not a QgsField object
        idx = self.mapLayer.dataProvider().fieldNameIndex(self.field)
        self.fieldType = self.mapLayer.fields()[idx].typeName()
        # automatic updating enabled
        if self.liveUpdateBtn.isChecked() == True:
            self.update_values()
            self.valueSearch.clearValue()
        elif self.clearOnChangeBtn.isChecked() == True:
            self.clear_listWidget()

    def change_layer(self):
        """ Clears the ListWidget and adds the fields of the
            current layer to the field combo box
        """
        if self.clearOnChangeBtn.isChecked() == True:
            self.clear_listWidget()

        # Try to disconnect old current layer from selection change ...
        if (self.liveUpdateBtn.isChecked() == True and
                self.selectedOnlyBtn.isChecked() == True):
            try:
                self.mapLayer.selectionChanged.disconnect()
            except TypeError:
                pass
        # ... change current layer property ...
        self.mapLayer = self.mMapLayerComboBox.currentLayer()

        # ... if no layer is apparent in combobox return None
        if self.mapLayer is None:
            self.field = None
            self.contains_null = None
            return None
        else:
            old_field = self.field
            # ... otherwise connect new layer if option is checked
            if (self.liveUpdateBtn.isChecked() == True and
                    self.selectedOnlyBtn.isChecked() == True):
                self.mapLayer.selectionChanged.connect(self.update_values)
            # ... then set the layer for the field combobox
            self.mFieldComboBox.setLayer(self.mapLayer)

            if len(self.mapLayer.fields()) > 0:
                # ... check if new layer has same named field
                if old_field in self.mapLayer.fields().names():
                    self.mFieldComboBox.setField(old_field)
                    self.contains_null = None
                    # trigger update_values here, because change_field is not triggered when
                    # data source is still the same after layer change as for duplicated layers
                    if self.liveUpdateBtn.isChecked() == True:
                        self.update_values()
                        self.valueSearch.clearValue()
                else:
                    field = self.mapLayer.fields()[0]
                    self.mFieldComboBox.setField(field.name())

    def change_sorting(self):
        """ Changes the sorting option for the ListWidgetItems
            based on the field type """
        # Do not use the sorting functionality of QListWidget
        if self.sortValuesBtn.isChecked() == True:
            self.sorting_enabled = True
        else:
            self.sorting_enabled = False

    def change_update_on_selection(self):
        """ Changes the widget to update the unique values on
            Field change and Selection change
        """
        # TODO: IMPROVE by disabling this connection when mapLayer has changed to None
        if self.mapLayer:
            if (self.liveUpdateBtn.isChecked() == True
               and self.selectedOnlyBtn.isChecked() == True):
                self.mapLayer.selectionChanged.connect(self.update_values)
            else:
                try:
                    self.mapLayer.selectionChanged.disconnect()
                except TypeError:
                    pass

    def clear_listWidget(self):
        """ Uses the native clear function to remove all list
            widget items and changes the values label
        """
        self.listWidget.clear()
        self.null_item = QListWidgetItem("NULL [Null]")
        self.valuesLbl.setText("Unique values")

    def clear_selection(self):
        """ Clears the selection of features from the current layer """
        self.mapLayer.removeSelection()

    def closeEvent(self, event):
        """ """
        self.closingPlugin.emit()
        event.accept()

    def copy_features(self):
        """ Copy all features with the selected unique values for the field """
        # store ids of currently selected features
        selected_ids = self.mapLayer.selectedFeatureIds()

        # get selected unique values
        items = self.listWidget.selectedItems()

        # check if all unique values are selected
        if (len(items) == self.listWidget.count() and
                self.selectedOnlyBtn.isChecked() == False):
            self.mapLayer.selectAll()
        else:
            # Build expression for selection
            expr = self.build_expression()

            # Check if 'Selected features only' is checked
            if self.selectedOnlyBtn.isChecked() == True:
                self.mapLayer.selectByExpression(expr, behavior=QgsVectorLayer.IntersectSelection)
            else:
                self.mapLayer.selectByExpression(expr)

        # Copy Features
        self.iface.setActiveLayer(self.mapLayer)
        self.iface.actionCopyFeatures().trigger()

        # Restore the original selection
        self.mapLayer.selectByIds(selected_ids)

    def copy_values(self):
        """ Copies the selected values of the ListWidget to the clipboard """
        items = self.listWidget.selectedItems()
        if len(items) == 1:
            values = items[0].text()
        else:
            values = '\n'.join([item.text() for item in items])
        QApplication.clipboard().setText(values)

    def copy_values_string(self):
        """ Copies the selected values of the ListWidget as string to the clipboard """
        items = self.listWidget.selectedItems()
        if len(items) == 1:
            str_values = "'" + items[0].text() + "'"
        else:
            str_values = '\n'.join(["'" + item.text() + "'" for item in items])
        QApplication.clipboard().setText(str_values)

    def deselect_values(self):
        """ De-selects all selected values shown in the ListWidget
        """
        self.listWidget.clearSelection()

    def eventFilter(self, source, event):
        """ Creates the event filter for the ContextMenu event """
        if (event.type() == QEvent.ContextMenu and
                source is self.listWidget):

            # Get number of selected items to build context menu entries based on this
            items = self.listWidget.selectedItems()

            if items:
                # Icon paths
                addSelect_ipath = self.plugin_dir + '/icons/mIconSelectAdd.svg'
                clearSelect_ipath = self.plugin_dir + '/icons/mActionDeselectActiveLayer.svg'
                copyFeatures_ipath = self.plugin_dir + '/icons/mActionEditCopy.svg'
                intersectSelect_ipath = self.plugin_dir + '/icons/mIconSelectIntersect.svg'
                removeSelect_ipath = self.plugin_dir + '/icons/mIconSelectRemove.svg'
                select_all_ipath = self.plugin_dir + '/icons/mActionSelectAll.svg'
                selected_ipath = self.plugin_dir + '/icons/mIconSelected.svg'

                # Create the context menu
                context_menu = QMenu(self.listWidget)

                # TODO: Shorten the code
                # if only one value is selected
                if len(items) == 1:
                    # Copy Actions
                    context_menu.addAction(u'Copy Value', self.copy_values)
                    context_menu.addAction(u'Copy Value as String',
                                           self.copy_values_string)
                    context_menu.addAction(QIcon(copyFeatures_ipath),
                                           u'Copy Features',
                                           self.copy_features)
                    context_menu.addSeparator()
                    # Selection Actions
                    if self.selectedOnlyBtn.isChecked() == True:
                        context_menu.addAction(QIcon(intersectSelect_ipath),
                                               u'Select Feature(s)',
                                               self.select_features)
                        context_menu.addAction(QIcon(removeSelect_ipath),
                                               u'Remove from Selection',
                                               self.remove_from_selection)
                    else:
                        context_menu.addAction(QIcon(selected_ipath),
                                               u'Select Feature(s)',
                                               self.select_features)
                        context_menu.addAction(QIcon(addSelect_ipath),
                                               u'Add to Selection',
                                               self.add_to_selection)
                    context_menu.addSeparator()
                    context_menu.addAction(u'Select All Values',
                                           self.select_all_values)
                    context_menu.addAction(u'Deselect Value',
                                           self.deselect_values)
                # when more than one value is selected
                else:
                    # Copy Actions
                    context_menu.addAction(u'Copy Values', self.copy_values)
                    context_menu.addAction(u'Copy Values as String',
                                           self.copy_values_string)
                    context_menu.addAction(QIcon(copyFeatures_ipath),
                                           u'Copy Features',
                                           self.copy_features)
                    context_menu.addSeparator()
                    # Selection Actions when all values are selected
                    if (len(items) == self.listWidget.count() and
                       self.selectedOnlyBtn.isChecked() == False):
                        if (self.mapLayer.selectedFeatureCount() ==
                           self.mapLayer.featureCount()):
                            context_menu.addAction(QIcon(clearSelect_ipath),
                                                   u'Clear Selection',
                                                   self.clear_selection)
                        else:
                            context_menu.addAction(QIcon(select_all_ipath),
                                                   u'Select All Features',
                                                   self.select_features)
                        context_menu.addSeparator()
                    # Selection Actions when all not values are selected
                    else:
                        if self.selectedOnlyBtn.isChecked() == True:
                            context_menu.addAction(QIcon(intersectSelect_ipath),
                                                   u'Select Features',
                                                   self.select_features)
                            context_menu.addAction(QIcon(removeSelect_ipath),
                                                   u'Remove from Selection',
                                                   self.remove_from_selection)
                        else:
                            context_menu.addAction(QIcon(selected_ipath),
                                                   u'Select Features',
                                                   self.select_features)
                            context_menu.addAction(QIcon(addSelect_ipath),
                                                   u'Add to Selection',
                                                   self.add_to_selection)
                        context_menu.addSeparator()
                        context_menu.addAction(u'Select All Values',
                                               self.select_all_values)
                    context_menu.addAction(u'Deselect Values',
                                           self.deselect_values)

                context_menu.exec_(event.globalPos())
                return True
        return super(UniqueValuesViewerDockWidget, self).eventFilter(source, event)

    def enable_only_selected_features(self):
        """ Enables functionality for updating the listwidget with the unique
            values on selection change if 'Only selected features' is checked
        """
        # TODO: IMPROVE by disabling this connection when mapLayer has changed to 'None'
        if self.mapLayer:
            if (self.liveUpdateBtn.isChecked() == True and
                    self.selectedOnlyBtn.isChecked() == True):
                self.mapLayer.selectionChanged.connect(self.update_values)
            else:
                try:
                    self.mapLayer.selectionChanged.disconnect()
                except TypeError:
                    pass
            self.update_values()

    def get_unique_values(self):
        """ Returns list of unique values for all features and True
            if NULL is within this list, otherwise False
        """

        # Get index for field
        idx = self.mapLayer.dataProvider().fieldNameIndex(self.field)

        # Get unique values by built_in function
        v_set = self.mapLayer.uniqueValues(idx)

        # If field contains datetime values, then convert them to string with toString method
        if self.fieldType.lower() in {'datetime', 'date'}:
            str_set = {str(v) if v.isNull() else v.toString(Qt.ISODate) for v in v_set}
        else:
            str_set = {str(v) for v in v_set}

        if "NULL" in str_set:
            str_set.remove("NULL")
            self.contains_null = True
        else:
            self.contains_null = False

        if self.sorting_enabled:
            if self.fieldType.lower() in {"string", "time", "date",
                                          "datetime",
                                          "boolean"}:
                return sorted(str_set)
            elif self.fieldType.lower() in {"double", "real"}:
                return sorted(str_set, key=float)
            elif self.fieldType.lower() in {"integer", "integer64"}:
                return sorted(str_set, key=int)
        else:
            return list(str_set)

    def get_unique_values_selected(self):
        """ Returns list of unique values only for selected features """

        # Get index for field
        idx = self.mapLayer.dataProvider().fieldNameIndex(self.field)
        v_set = set()

        # If field contains datetime values, then convert them to string with toString method
        if self.fieldType.lower() in ('datetime', 'date'):
            for feat in self.mapLayer.getSelectedFeatures():
                v_set.add(feat.attributes()[idx])
            str_set = {str(v) if v.isNull() else v.toString(Qt.ISODate) for v in v_set}
        else:
            str_set = set()
            # Get unique values from selected features
            for feat in self.mapLayer.getSelectedFeatures():
                str_set.add(str(feat.attributes()[idx]))

        if "NULL" in v_set:
            str_set.remove("NULL")
            self.contains_null = True
        else:
            self.contains_null = False

        if self.sorting_enabled:
            if self.fieldType.lower() in {"string", "time", "date",
                                          "datetime",
                                          "boolean"}:
                return sorted(str_set)
            elif self.fieldType.lower() in {"double", "real"}:
                return sorted(str_set, key=float)
            elif self.fieldType.lower() in {"integer", "integer64"}:
                return sorted(str_set, key=int)
        else:
            return list(str_set)

    def keyPressEvent(self, event):
        """ Cleares the searchbar when Escape was pressed """
        if self.valueSearch.hasFocus() and event.key() == Qt.Key_Escape:
            self.valueSearch.clearValue()
            self.valueSearch.clearFocus()
        elif (self.valueSearch.hasFocus() and event.key() in
              {Qt.Key_Return, Qt.Key_Enter}):
            self.listWidget.setFocus()

    def layerRefresh(self, lyr):
        """ Refreshes a layer in QGIS map canvas

        :param lyr: The layer that will be refreshed
        :type lyr: QgsMapLayer
        """
        if self.iface.mapCanvas().isCachingEnabled():
            lyr.triggerRepaint()
        else:
            self.iface.mapCanvas().refresh()

    def remove_from_selection(self):
        """ """
        expr = self.build_expression()
        rm = self.mapLayer.selectByExpression(expr, behavior=QgsVectorLayer.RemoveFromSelection)
        # TODO: Improve here, only remove listwidget items which are no longer selected
        # instead of updating values
        self.update_values()

    def search_value(self):
        """ Searches ListWidget for matching values and updates it to
            only show the matching ones
        """
        text = self.valueSearch.text()
        # Only search if text is not empty
        if text:
            # TODO: Improve Search..
            # - remember which items were selected, so that search can be used to
            #   look for different values and select them one by one
            # - make it work for different field types, e.g. dates
            # - make it more efficient/improve performance
            # - add search options to the settings menu, e.g. for string/text fields
            #   'starts with', 'contains'

            # Search all items which do not contain the search value!
            text_not_contained = self.listWidget.findItems("^((?!%s).)*$" % text,
                                                           Qt.MatchRegExp)  # use Qt.MatchRegularExpression for Qt 5.15+
            # Search all items which do contain the search value
            text_contained = self.listWidget.findItems(text, Qt.MatchContains)

            # Hide all items which are not contained
            for item in text_not_contained:
                if not item.isHidden():
                    item.setHidden(True)
            # Show all items which are contained
            for item in text_contained:
                if item.isHidden():
                    item.setHidden(False)

    def select_all_values(self):
        """ Selects all values shown in the ListWidget
        """
        self.listWidget.selectAll()

    def select_features(self):
        """ Select features based on unique values """
        items = self.listWidget.selectedItems()
        if (len(items) == self.listWidget.count() and
                self.selectedOnlyBtn.isChecked() == False):
            self.mapLayer.selectAll()
            print("Alle ausgewählt")
        else:
            expr = self.build_expression()
            self.mapLayer.selectByExpression(expr)
            # Update values for list widget
            if self.selectedOnlyBtn.isChecked() == True:
                self.update_values()
            print(expr)

    def show_values(self):
        """ Shows all items of the listwidget after clearing the searchbar
            and if the items were hidden
        """
        for i in range(self.listWidget.count()):
            if self.listWidget.item(i).isHidden():
                self.listWidget.item(i).setHidden(False)


    def sync_iface_layer_changed(self, layer):
        """ Sets the new active layer of the QGIS interface, as current layer in the
            combobox if its data provider is not in list of excluded providers
        """
        if layer is not None:
            if layer.dataProvider().name() not in EXCLUDE_PROVIDERS:
                self.mMapLayerComboBox.setLayer(layer)

    def update_values(self):
        """ Updates the values in the list widget """
        self.clear_listWidget()
        if self.listWidget.selectionMode() == QAbstractItemView.NoSelection:
            self.listWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.listWidget.setStyleSheet("QListWidget {font-style:normal;}")

        # Get unique values, convert to list and sort
        if self.mMapLayerComboBox.currentLayer() is not None:
            self.unique_values = []
            try:
                if self.selectedOnlyBtn.isChecked() == False:
                    values = self.get_unique_values()
                    self.unique_values = values
                    self.valuesLbl.setText(f"Unique values [{len(self.unique_values)}]")

                elif self.mapLayer.selectedFeatureCount() != 0:
                    values = self.get_unique_values_selected()
                    self.unique_values = values
                    self.valuesLbl.setText(f"Unique values [{len(self.unique_values)}]")
                    self.layerRefresh(self.mapLayer)
                else:
                    self.contains_null = False
                    self.unique_values = ["No features selected"]
                    self.listWidget.setSelectionMode(QAbstractItemView.NoSelection)
                    self.listWidget.setStyleSheet("QListWidget {font-style:italic;}")

                if self.contains_null:
                    self.listWidget.addItem(self.null_item)
            except SystemError:
                self.iface.messageBar().pushMessage("Error",
                                                    "The set of values contained an error!",
                                                    level=Qgis.Critical,
                                                    duration=2)
                self.unique_values = ["Error occurred when calculating unique values!"]
                self.listWidget.setSelectionMode(QAbstractItemView.NoSelection)
                self.listWidget.setStyleSheet("QListWidget {font-style:italic; color:#ff1a1a;}")

            # Add unique values as items to list widget
            self.listWidget.addItems(self.unique_values)
